package main

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	zeekWebEndpoint = "http://zeek.k3d.localhost"
	lokiEndpoint    = "http://loki.k3d.localhost/loki/api/v1/query_range"
)

func TestZeekLogs(t *testing.T) {
	testCases := []struct {
		testName string
		path     string
		method   string
	}{
		{"index", "index", http.MethodGet},
		{"foo bar", "foo/bar", http.MethodPost},
	}

	for _, tc := range testCases {
		// In order to ensure the logs generated by each test are unique in some way
		// we will append a milli timestamp value to the path value sent to nginx.
		// This will always result in a 404, but that's okay as we just want to ensure
		// logs reach loki in a short period of time.
		path, err := url.JoinPath(tc.path, fmt.Sprintf("%d", time.Now().UnixMilli()))
		require.NoError(t, err)

		t.Run(tc.testName+"_generate_logs", func(t *testing.T) {
			url, err := url.JoinPath(zeekWebEndpoint, path)
			require.NoError(t, err)

			resp, err := http.Get(url)
			require.NoError(t, err)
			assert.NotNil(t, resp)
		})

		t.Run(tc.testName+"_ensure_logs_in_loki", func(t *testing.T) {
			u, err := url.Parse(lokiEndpoint)
			require.NoError(t, err)

			params := url.Values{}
			params.Add("query", "{job=\"zeek\"}")
			u.RawQuery = params.Encode()

			req, err := http.NewRequest(tc.method, u.String(), nil)
			require.NoError(t, err)

			req.Header.Add("X-Scope-OrgId", "zeek")

			ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
			defer cancel()

			for {
				select {
				case <-time.After(time.Second):
					client := &http.Client{Timeout: 5 * time.Second}
					resp, err := client.Do(req)
					assert.NoError(t, err)
					assert.NotNil(t, resp)
					defer resp.Body.Close()

					b, err := io.ReadAll(resp.Body)
					require.NoError(t, err)
					if strings.Contains(string(b), path) {
						return
					}
					t.Log("waiting for logs in loki...")
				case <-ctx.Done():
					t.Log(ctx.Err())
					t.FailNow()
				}
			}
		})
	}
}
